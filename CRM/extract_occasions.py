#!/usr/bin/env python3
"""
Occasion Extraction Script

This script extracts occasions from legacy and current order data,
porting all logic from app/Services/CrmOrderIntegrationService.php

Author: Generated by Claude Code
Date: 2025-08-29
"""

import pandas as pd
import re
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import logging
from collections import defaultdict

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class OccasionExtractor:
    def __init__(self):
        self.existing_customers = {}
        self.occasions = []
        self.customer_occasions = defaultdict(list)
        
    def load_existing_customers(self, csv_path: str):
        """Load existing customers for email matching"""
        logger.info(f"Loading existing customers from {csv_path}")
        df = pd.read_csv(csv_path)
        
        for _, row in df.iterrows():
            email = str(row['primary_email']).lower().strip()
            self.existing_customers[email] = {
                'customer_id': row['customer_id'],
                'buyer_name': row['buyer_name'],
                'primary_phone': row.get('primary_phone', ''),
                'primary_email': email,
                'first_order': row.get('first_order', ''),
                'last_order': row.get('last_order', ''),
                'orders_count': int(row.get('orders_count', 0)),
                'fav_flavors': row.get('fav_flavors', ''),
                'eggs_ok': row.get('eggs_ok', ''),
                'allergens': row.get('allergens', ''),
                'marketing_opt_in': bool(row.get('marketing_opt_in', 0)),
                'channel_preference': row.get('channel_preference', ''),
                'notes': row.get('notes', '')
            }
        
        logger.info(f"Loaded {len(self.existing_customers)} existing customers")
    
    def detect_occasion_type(self, message_on_cake: str, custom_decoration: str) -> Optional[str]:
        """
        Port of detectOccasionType() from CrmOrderIntegrationService.php
        Detect occasion type from message and decoration text
        """
        message_on_cake = str(message_on_cake or '').lower()
        custom_decoration = str(custom_decoration or '').lower()
        combined_text = f"{message_on_cake} {custom_decoration}"
        
        # Birthday detection
        if re.search(r'\b(happy birthday|birthday|bday)\b', combined_text, re.IGNORECASE):
            return 'birthday'
        
        # Anniversary detection
        if re.search(r'\b(anniversary|anni)\b', combined_text, re.IGNORECASE):
            return 'anniversary'
        
        # Graduation detection
        if re.search(r'\b(graduation|graduate|grad)\b', combined_text, re.IGNORECASE):
            return 'graduation'
        
        # Baby shower detection
        if re.search(r'\b(baby shower|shower)\b', combined_text, re.IGNORECASE):
            return 'baby_shower'
        
        # Gender reveal detection
        if re.search(r'\b(gender reveal)\b', combined_text, re.IGNORECASE):
            return 'gender_reveal'
        
        # Wedding detection
        if re.search(r'\b(wedding|marriage|engagement)\b', combined_text, re.IGNORECASE):
            return 'wedding'
        
        # Holiday detection
        if re.search(r'\b(christmas|thanksgiving|valentine|easter|halloween)\b', combined_text, re.IGNORECASE):
            return 'holiday'
        
        return None
    
    def extract_honoree_name(self, message_on_cake: str, custom_decoration: str) -> Optional[str]:
        """
        Port of extractHonoreeName() from CrmOrderIntegrationService.php
        Extract honoree name from order message
        """
        message = str(message_on_cake or '')
        
        # Birthday patterns
        match = re.search(r'happy birthday\s+([A-Za-z\s]+)', message, re.IGNORECASE)
        if match:
            name = match.group(1).strip()
            return self.clean_honoree_name(name)
        
        match = re.search(r'([A-Za-z\s]+)\'s birthday', message, re.IGNORECASE)
        if match:
            name = match.group(1).strip()
            return self.clean_honoree_name(name)
        
        # Anniversary patterns
        match = re.search(r'happy anniversary\s+([A-Za-z\s]+)', message, re.IGNORECASE)
        if match:
            name = match.group(1).strip()
            return self.clean_honoree_name(name)
        
        # General patterns
        match = re.search(r'happy\s+\w+\s+([A-Za-z\s]+)', message, re.IGNORECASE)
        if match:
            name = match.group(1).strip()
            # Filter out common words
            if name.lower() not in ['to', 'for', 'and', 'the', 'a', 'an', 'with']:
                return self.clean_honoree_name(name)
        
        return None
    
    def clean_honoree_name(self, name: str) -> str:
        """
        Clean honoree name by removing occasion keywords
        """
        if not name:
            return name
        
        # Remove birthday, anniversary, etc. from names
        name = re.sub(r'\b(birthday|bday|anniversary|anni|graduation|graduate|grad)\b', '', name, flags=re.IGNORECASE)
        
        # Clean up extra spaces and punctuation
        name = re.sub(r'\s+', ' ', name)  # Multiple spaces to single
        name = name.strip(' .,!-')  # Remove leading/trailing punctuation
        
        return name.strip()
    
    def is_within_date_window(self, date1: datetime, date2: datetime, days_window: int = 7) -> bool:
        """
        Port of isWithinDateWindow() from CrmOrderIntegrationService.php
        Check if dates are within specified window (Â±7 days by default)
        """
        if not date1 or not date2:
            return False
        
        # Calculate expected date for same year
        expected_date = datetime(date2.year, date1.month, date1.day)
        
        # If expected date is more than 6 months away, try previous or next year
        if abs((date2 - expected_date).days) > 180:
            if date2 < expected_date:
                expected_date = datetime(date2.year - 1, date1.month, date1.day)
            else:
                expected_date = datetime(date2.year + 1, date1.month, date1.day)
        
        # Check if within window
        days_difference = abs((date2 - expected_date).days)
        return days_difference <= days_window
    
    def find_matching_occasion(self, customer_email: str, occasion_type: str, order_date: datetime) -> Optional[Dict]:
        """
        Port of findMatchingOccasion() from CrmOrderIntegrationService.php
        Find existing occasion within date window
        """
        customer_occasions = self.customer_occasions.get(customer_email, [])
        
        for occasion in customer_occasions:
            if (occasion['occasion_type'] == occasion_type and 
                self.is_within_date_window(occasion['last_order_date_latest'], order_date)):
                return occasion
        
        return None
    
    def calculate_confidence(self, history_count: int, history_years: str) -> str:
        """
        Port of calculateConfidence() from CrmOrderIntegrationService.php
        Calculate occasion confidence based on history
        """
        if history_count == 1:
            return 'medium'  # First occurrence
        
        if history_count >= 3:
            return 'high'  # 3+ orders = established pattern
        
        if history_count == 2 and history_years:
            # Check if orders are from different years
            years = [y.strip() for y in history_years.split(',')]
            if len(set(years)) >= 2:
                return 'high'  # Multiple years = strong pattern
        
        return 'medium'
    
    def calculate_next_anticipated_order_date(self, last_order_date: datetime, history_count: int, occasion_type: str = None) -> Optional[datetime]:
        """
        Calculate next anticipated order date - always in the future
        For birthdays/anniversaries: calculate next occurrence after today
        For other occasions: use average frequency if multiple orders
        """
        if not last_order_date:
            return None
        
        today = datetime.now()
        
        # For recurring occasions (birthday, anniversary), find next occurrence
        if occasion_type in ['birthday', 'anniversary']:
            # Start with this year's date
            try:
                next_date = last_order_date.replace(year=today.year)
            except ValueError:
                # Handle leap year edge case (Feb 29)
                next_date = last_order_date.replace(year=today.year, day=28)
            
            # If this year's date has passed, move to next year
            if next_date <= today:
                try:
                    next_date = last_order_date.replace(year=today.year + 1)
                except ValueError:
                    # Handle leap year edge case (Feb 29)
                    next_date = last_order_date.replace(year=today.year + 1, day=28)
            
            return next_date
        
        # For non-recurring occasions, estimate based on order frequency
        else:
            # Default: add 1 year but ensure it's in the future
            next_date = last_order_date.replace(year=last_order_date.year + 1)
            
            # If still in the past, move to current year + 1
            while next_date <= today:
                next_date = next_date.replace(year=next_date.year + 1)
            
            return next_date
    
    def process_legacy_orders(self, csv_path: str):
        """Process legacy orders CSV file"""
        logger.info(f"Processing legacy orders from {csv_path}")
        df = pd.read_csv(csv_path)
        
        processed_count = 0
        occasion_count = 0
        
        for _, row in df.iterrows():
            try:
                # Parse order data
                pickup_date_str = str(row['Date of cake pickup']).strip()
                pickup_date = datetime.strptime(pickup_date_str, '%m/%d/%Y')
                
                customer_name = str(row['Name']).strip()
                email = str(row['Email address']).lower().strip()
                phone = str(row.get('Phone Number', '')).strip()
                message_on_cake = str(row.get('Message on cake', ''))
                custom_decoration = str(row.get('Custom decoration', ''))
                
                # Skip if no email
                if not email or email == 'nan':
                    continue
                
                # Detect occasion
                occasion_type = self.detect_occasion_type(message_on_cake, custom_decoration)
                if not occasion_type:
                    processed_count += 1
                    continue
                
                # Extract honoree
                honoree_name = self.extract_honoree_name(message_on_cake, custom_decoration)
                
                # Find existing customer
                customer_id = self.existing_customers.get(email, {}).get('customer_id', email)
                
                # Check for existing occasion
                existing_occasion = self.find_matching_occasion(email, occasion_type, pickup_date)
                
                if existing_occasion:
                    # Update existing occasion
                    existing_occasion['history_count'] += 1
                    if existing_occasion['history_years']:
                        existing_occasion['history_years'] += f",{pickup_date.year}"
                    else:
                        existing_occasion['history_years'] = str(pickup_date.year)
                    
                    # Update if this is a more recent order
                    if pickup_date > existing_occasion['last_order_date_latest']:
                        existing_occasion['last_order_date_latest'] = pickup_date
                        existing_occasion['honoree_name'] = honoree_name or existing_occasion['honoree_name']
                    
                    # Recalculate confidence
                    existing_occasion['anchor_confidence'] = self.calculate_confidence(
                        existing_occasion['history_count'], 
                        existing_occasion['history_years']
                    )
                else:
                    # Create new occasion
                    occasion = {
                        'customer_id': customer_id,
                        'customer_email': email,
                        'customer_name': customer_name,
                        'occasion_type': occasion_type,
                        'honoree_name': honoree_name,
                        'anchor_confidence': 'medium',
                        'last_order_date_latest': pickup_date,
                        'history_count': 1,
                        'history_years': str(pickup_date.year),
                        'source': 'legacy'
                    }
                    
                    self.customer_occasions[email].append(occasion)
                    occasion_count += 1
                
                processed_count += 1
                
            except Exception as e:
                logger.warning(f"Error processing legacy row: {e}")
                continue
        
        logger.info(f"Processed {processed_count} legacy orders, extracted {occasion_count} new occasions")
    
    def process_ctsite_orders(self, csv_path: str):
        """Process CTsite orders CSV file (confirmed orders only)"""
        logger.info(f"Processing CTsite orders from {csv_path}")
        df = pd.read_csv(csv_path)
        
        # Filter for confirmed orders only
        df = df[df['status'] == 'confirmed']
        logger.info(f"Found {len(df)} confirmed orders")
        
        processed_count = 0
        occasion_count = 0
        
        for _, row in df.iterrows():
            try:
                # Parse order data
                pickup_date_str = str(row['pickup_date']).strip()
                pickup_date = datetime.strptime(pickup_date_str, '%Y-%m-%d')
                
                customer_name = str(row['customer_name']).strip()
                email = str(row['email']).lower().strip()
                phone = str(row.get('phone', '')).strip()
                message_on_cake = str(row.get('message_on_cake', ''))
                custom_decoration = str(row.get('custom_decoration', ''))
                
                # Skip if no email
                if not email or email == 'nan':
                    continue
                
                # Detect occasion
                occasion_type = self.detect_occasion_type(message_on_cake, custom_decoration)
                if not occasion_type:
                    processed_count += 1
                    continue
                
                # Extract honoree
                honoree_name = self.extract_honoree_name(message_on_cake, custom_decoration)
                
                # Find existing customer
                customer_id = self.existing_customers.get(email, {}).get('customer_id', email)
                
                # Check for existing occasion
                existing_occasion = self.find_matching_occasion(email, occasion_type, pickup_date)
                
                if existing_occasion:
                    # Update existing occasion
                    existing_occasion['history_count'] += 1
                    if existing_occasion['history_years']:
                        existing_occasion['history_years'] += f",{pickup_date.year}"
                    else:
                        existing_occasion['history_years'] = str(pickup_date.year)
                    
                    # Update if this is a more recent order
                    if pickup_date > existing_occasion['last_order_date_latest']:
                        existing_occasion['last_order_date_latest'] = pickup_date
                        existing_occasion['honoree_name'] = honoree_name or existing_occasion['honoree_name']
                    
                    # Recalculate confidence
                    existing_occasion['anchor_confidence'] = self.calculate_confidence(
                        existing_occasion['history_count'], 
                        existing_occasion['history_years']
                    )
                    
                    # Mark as current system source
                    existing_occasion['source'] = 'both' if existing_occasion.get('source') == 'legacy' else 'current'
                else:
                    # Create new occasion
                    occasion = {
                        'customer_id': customer_id,
                        'customer_email': email,
                        'customer_name': customer_name,
                        'occasion_type': occasion_type,
                        'honoree_name': honoree_name,
                        'anchor_confidence': 'medium',
                        'last_order_date_latest': pickup_date,
                        'history_count': 1,
                        'history_years': str(pickup_date.year),
                        'source': 'current'
                    }
                    
                    self.customer_occasions[email].append(occasion)
                    occasion_count += 1
                
                processed_count += 1
                
            except Exception as e:
                logger.warning(f"Error processing CTsite row: {e}")
                continue
        
        logger.info(f"Processed {processed_count} CTsite orders, extracted {occasion_count} new occasions")
    
    def calculate_dates_for_occasions(self):
        """Calculate anchor dates and next anticipated dates for all occasions"""
        logger.info("Calculating dates for all occasions")
        
        for customer_email, occasions in self.customer_occasions.items():
            for occasion in occasions:
                last_order_date = occasion['last_order_date_latest']
                
                # Calculate anchor week (start of week containing the order)
                days_since_monday = last_order_date.weekday()
                anchor_week_start = last_order_date - timedelta(days=days_since_monday)
                occasion['anchor_week_start_date'] = anchor_week_start
                
                # Calculate next anticipated order date
                next_date = self.calculate_next_anticipated_order_date(
                    last_order_date, 
                    occasion['history_count'],
                    occasion['occasion_type']
                )
                occasion['next_anticipated_order_date'] = next_date
                
                # Calculate reminder date (Sunday 8 days before anchor week)
                if next_date:
                    next_anchor_week = next_date - timedelta(days=next_date.weekday())
                    reminder_date = next_anchor_week - timedelta(days=8)
                    occasion['reminder_date'] = reminder_date
                
                # Add fields for database compatibility
                occasion['reminder_sent'] = False
                occasion['notes'] = ''
                occasion['created_at'] = datetime.now()
                occasion['updated_at'] = datetime.now()
    
    def export_to_excel(self, output_path: str):
        """Export extracted occasions to Excel file"""
        logger.info("Exporting occasions to Excel")
        
        # Flatten occasions list
        all_occasions = []
        for occasions in self.customer_occasions.values():
            all_occasions.extend(occasions)
        
        # Convert to DataFrame
        df_data = []
        for occasion in all_occasions:
            df_data.append({
                'customer_id': occasion['customer_id'],
                'customer_email': occasion['customer_email'],
                'customer_name': occasion['customer_name'],
                'occasion_type': occasion['occasion_type'],
                'honoree_name': occasion.get('honoree_name', ''),
                'anchor_confidence': occasion['anchor_confidence'],
                'last_order_date_latest': occasion['last_order_date_latest'].strftime('%Y-%m-%d'),
                'history_count': occasion['history_count'],
                'history_years': occasion.get('history_years', ''),
                'anchor_week_start_date': occasion.get('anchor_week_start_date', '').strftime('%Y-%m-%d') if occasion.get('anchor_week_start_date') else '',
                'next_anticipated_order_date': occasion.get('next_anticipated_order_date', '').strftime('%Y-%m-%d') if occasion.get('next_anticipated_order_date') else '',
                'reminder_date': occasion.get('reminder_date', '').strftime('%Y-%m-%d') if occasion.get('reminder_date') else '',
                'reminder_sent': 0,
                'notes': '',
                'source': occasion.get('source', ''),
                'created_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'updated_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            })
        
        df = pd.DataFrame(df_data)
        
        # Save to Excel
        with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
            df.to_excel(writer, sheet_name='Extracted_Occasions', index=False)
            
            # Add summary sheet
            summary_data = {
                'Metric': [
                    'Total Occasions Extracted',
                    'Unique Customers',
                    'Birthday Occasions',
                    'Anniversary Occasions',
                    'Other Occasions',
                    'High Confidence',
                    'Medium Confidence',
                    'From Legacy System',
                    'From Current System',
                    'From Both Systems'
                ],
                'Count': [
                    len(all_occasions),
                    len(set(o['customer_email'] for o in all_occasions)),
                    len([o for o in all_occasions if o['occasion_type'] == 'birthday']),
                    len([o for o in all_occasions if o['occasion_type'] == 'anniversary']),
                    len([o for o in all_occasions if o['occasion_type'] not in ['birthday', 'anniversary']]),
                    len([o for o in all_occasions if o['anchor_confidence'] == 'high']),
                    len([o for o in all_occasions if o['anchor_confidence'] == 'medium']),
                    len([o for o in all_occasions if o.get('source') == 'legacy']),
                    len([o for o in all_occasions if o.get('source') == 'current']),
                    len([o for o in all_occasions if o.get('source') == 'both'])
                ]
            }
            
            summary_df = pd.DataFrame(summary_data)
            summary_df.to_excel(writer, sheet_name='Summary', index=False)
        
        logger.info(f"Exported {len(all_occasions)} occasions to {output_path}")
        return len(all_occasions)

def main():
    """Main execution function"""
    logger.info("Starting occasion extraction process")
    
    # Initialize extractor
    extractor = OccasionExtractor()
    
    # Load existing customers
    extractor.load_existing_customers('existing_customers.csv.csv')
    
    # Process legacy orders
    extractor.process_legacy_orders('legacy_orders.csv.csv')
    
    # Process CTsite orders
    extractor.process_ctsite_orders('CTsite_orders.csv.csv')
    
    # Calculate dates
    extractor.calculate_dates_for_occasions()
    
    # Export results
    total_occasions = extractor.export_to_excel('extracted_occasions.xlsx')
    
    logger.info(f"Occasion extraction completed successfully!")
    logger.info(f"Total occasions extracted: {total_occasions}")
    
    return total_occasions

if __name__ == "__main__":
    main()